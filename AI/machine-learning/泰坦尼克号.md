---
title: begin:泰坦尼克
author: Alen
published: 2025-10-14
description: "泰坦尼克号数据集实践-好的开始"
first_level_category: "AI"
second_level_category: "机器学习"
tags: ['机器学习']
draft: false
---

# 泰坦尼克号数据集实践

## 数据获取

### Seaborn库获取

```
conda install seaborn
```

加载数据集：

```python
import seaborn as sns
df = sns.load_dataset('titanic')
```

### Kaggle获取

 [Titanic - Machine Learning from Disaster](https://www.google.com/url?sa=E&q=https%3A%2F%2Fwww.kaggle.com%2Fc%2Ftitanic) ， 在 "Data" 标签页下，下载 train.csv 和 test.csv 文件到本地项目文件夹。

加载数据

```python
import pandas as pd
df = pd.read_csv('train.csv')
```

## 数据预分析

### .head()：初见数据，建立直观印象

主要作用是：

- **理解特征含义**：我们可以看到列名，并猜测它们的含义。例如，survived (是否生还)，pclass (船舱等级)， sex (性别), age (年龄)，sibsp (同行的兄弟姐妹/配偶数)，parch (同行的父母/子女人数)，fare (票价)。
- **观察数据格式**：
  - survived 是 0 和 1，这是典型的**二元数值型**变量，适合做分类任务的目标。
  - sex 是 'male' 和 'female'，是**文本类别型**变量。
  - deck 列在第一行就是 NaN (Not a Number)，这是一个**缺失值**的直接信号。
- **发现潜在的冗余信息**：
  - 我们同时看到了 survived (0/1) 和 alive ('no'/'yes') 这两列。它们表达的是完全相同的信息，只是格式不同。在后续处理中，我们只需要保留一列。
  - 同样，pclass (1,2,3) 和 class ('First', 'Second', 'Third') 也是冗余的。
  - embarked ('S', 'C') 和 embark_town ('Southampton', 'Cherbourg') 也是如此。

```bash
   survived  pclass     sex   age  ...  deck  embark_town  alive  alone
0         0       3    male  22.0  ...   NaN  Southampton     no  False
1         1       1  female  38.0  ...     C    Cherbourg    yes  False
2         1       3  female  26.0  ...   NaN  Southampton    yes   True
3         1       1  female  35.0  ...     C  Southampton    yes  False
4         0       3    male  35.0  ...   NaN  Southampton     no   True
```

**初步结论**：数据集包含数值、文本、布尔等多种数据类型，存在明显的缺失值和信息冗余的列。

### info()：深入了解结构

info() 提供了数据的整体结构信息，是发现**缺失值**和**数据类型**问题的关键。

- **数据集规模**：RangeIndex: 891 entries 告诉我们这个数据集中共有 **891条记录**（代表891名乘客）。这是我们所有分析的基准。
- **数据类型 (Dtype)**：
  - object 类型通常是字符串，如 sex, embarked, who。这些在喂给机器学习模型前需要进行编码（如 **One-Hot Encoding**）。
  - int64, float64 是数值型，可以直接用于计算。
  - category 和 bool 是特殊的类型，通常也需要转换成数值。
- **发现缺失值（核心洞察）**：通过对比每一列的 Non-Null Count 和总数 891，可以精确地定位缺失数据：
  - **age**: 只有 714 non-null，说明有 891 - 714 = 177 个年龄数据是缺失的。这是一个比较严重的问题，需要后续处理（填充或删除）。
  - **embarked** 和 **embark_town**: 只有 889 non-null，说明有 891 - 889 = 2 个登船港口数据缺失。数量很少，容易处理。
  - **deck**: 只有 203 non-null，说明有 891 - 203 = 688 个船舱号数据缺失。**缺失率极高（超过77%）**，这个特征可能无法使用，后续很大概率会直接删除。

```json
RangeIndex: 891 entries, 0 to 890
Data columns (total 15 columns):
 #   Column       Non-Null Count  Dtype
---  ------       --------------  -----
 0   survived     891 non-null    int64
 1   pclass       891 non-null    int64
 2   sex          891 non-null    object
 3   age          714 non-null    float64
 4   sibsp        891 non-null    int64
 5   parch        891 non-null    int64
 6   fare         891 non-null    float64
 7   embarked     889 non-null    object
 8   class        891 non-null    category
 9   who          891 non-null    object
 10  adult_male   891 non-null    bool
 11  deck         203 non-null    category
 12  embark_town  889 non-null    object
 13  alive        891 non-null    object
 14  alone        891 non-null    bool
```

**初步结论**：deck列因缺失太多基本无用，age列有显著的缺失需要重点处理，embarked列有少量缺失可以轻松修复。

### isnull().sum()：量化缺失问题

这个命令是 info() 中关于缺失值信息的提炼和确认，让我们更直观地看到问题。

- **deck: 688**:    再次确认，deck列的缺失问题是最大的。
- **age: 177**:    确认了age是第二大缺失项。
- **embarked:  2** 和 **embark_town:  2**: 确认了这两列有少量缺失。
- **其他列: 0**: 告诉我们其他列的数据是完整的，这非常好。

```json
各列缺失值数量:
survived         0
pclass           0
sex              0
age            177
sibsp            0
parch            0
fare             0
embarked         2
class            0
who              0
adult_male       0
deck           688
embark_town      2
alive            0
alone            0
dtype: int64
```

**初步结论**：我们已经精确锁定了需要进行缺失值处理的3个主要特征：deck, age, embarked。

### describe()：洞察数值特征的分布与规律

describe() 提供了所有**数值型**列的统计摘要，这是挖掘数据规律和发现异常值的金矿。

- **survived (目标变量)**：
  - mean: 0.383838：因为生还为1，遇难为0，所以均值就是**生还率**。我们可以得出一个非常重要的基线结论：**数据集中总体的生还率约为 38.4%**。
- **pclass (船舱等级)**：
  - mean: 2.3：平均等级是2.3，说明大部分乘客（超过一半）都在三等舱（因为中位数50%是3.0）。
- **age (年龄)**：
  - count: 714：再次确认了非空值的数量。
  - mean: 29.7, 50% (median): 28.0：乘客的平均年龄约30岁，中位数和均值很接近，说明年龄分布可能不会太偏斜。
  - min: 0.42, max: 80.0：乘客年龄跨度很大，从婴儿到老人都有。
- **sibsp & parch (家庭成员数)**：
  - 75%: 1.000000 (sibsp) 和 75%: 0.000000 (parch)：这两个值告诉我们，**超过75%的乘客没有同行父母/子女，且大部分乘客的同行兄弟姐妹/配偶数不超过1人**。结合起来看，大多数人是独自或以小家庭形式出行。
- **fare (票价)**：
  - mean: 32.2 vs 50% (median): 14.45：**均值远大于中位数**，这是一个强烈的信号，表明票价分布是严重右偏的。
  - std: 49.7：标准差非常大，甚至超过了均值，说明票价的波动范围极广。
  - max: 512.3：存在极高的票价，这很可能是异常值或极端值，是那些豪华头等舱的票价，它们拉高了整体的平均值。

```json
          survived      pclass         age       sibsp       parch        fare
count  891.000000  891.000000  714.000000  891.000000  891.000000  891.000000
mean     0.383838    2.308642   29.699118    0.523008    0.381594   32.204208
std      0.486592    0.836071   14.526497    1.102743    0.806057   49.693429
min      0.000000    1.000000    0.420000    0.000000    0.000000    0.000000
25%      0.000000    2.000000   20.125000    0.000000    0.000000    7.910400
50%      0.000000    3.000000   28.000000    0.000000    0.000000   14.454200
75%      1.000000    3.000000   38.000000    1.000000    0.000000   31.000000
max      1.000000    3.000000   80.000000    8.000000    6.000000  512.329200
```



### **综合分析与下一步行动计划**

通过这四个命令，我们几乎可以为后续的数据清洗和特征工程制定一个完整的计划：

1. **数据清洗**:
   - **删除冗余列**：从 survived/alive, pclass/class, embarked/embark_town 中各选一列保留。
   - **处理缺失值**：
     - **删除deck列**，因为缺失值太多。
     - **填充age列**，可以使用均值、中位数填充，或者更高级的方法（如根据头衔Mr., Mrs.的平均年龄来填充）。
     - **填充embarked列**，可以使用最常见的登船港口来填充。
2. **特征工程**:
   - 将sex、embarked等文本类别型特征转换为数值（如One-Hot Encoding）。
   - 可以考虑将sibsp和parch合并成一个新的特征，如family_size（家庭总人数）。
   - 由于fare和age的分布和范围差异很大，后续建模时需要进行**特征缩放（标准化或归一化）**。
3. **初步假设建立**:
   - 生还率可能与pclass和fare有关（高等级/高票价的乘客是否生还率更高？）。
   - 生还率可能与sex有关（女性的生还率是否更高？）。
   - 生还率可能与age有关（儿童的生还率是否更高？）。

## 数据绘图

